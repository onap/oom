# Copyright Â© 2020 Bitnami, AT&T, highstreet technologies
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Default values for elasticsearch
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

global: # global defaults
  persistence:
    mountPath: /dockerdata-nfs
    backup:
      mountPath: /dockerdata-nfs/backup
  repository: nexus3.onap.org:10001
  readinessRepository: oomk8s
  readinessImage: readiness-check:2.0.2
#TODO check if required
  coordinating:
    name: coordinating-only
  kibanaEnabled: false
# aaf integration
aaf_init:
  addconfig: true
  # You might want this in your own app.  For AAF, we store in global
  # replicas: 1
  fqdn: "sdnc"
  image: onap/aaf/aaf_agent:2.1.15
  app_ns: "org.osaaf.aaf"
  fqi_namespace: org.onap.sdnc
  fqi: "sdnc@sdnc.onap.org"
  public_fqdn: "aaf.osaaf.org"
  deploy_fqi: "deployer@people.osaaf.org"
  cadi_latitude: "52.5"
  cadi_longitude: "13.4"
  persistence:
    enabled: true
    config:
      #existingClaim:
      # You will want "Reatan" in non-Hello Example.
      volumeReclaimPolicy: Delete
      accessMode: ReadWriteMany
      size: 40M
      storageClass: "manual"
      mountPath: "/dockerdata-nfs"
      mountSubPath: "elasticsearch/aaf"
      

# nginx image
nginx:
  registry: docker.io
  image: bitnami/nginx
  tag: 1.16-debian-9
  pullPolicy: IfNotPresent
## Custom server block to be added to NGINX configuration
## PHP-FPM example server block:
  serverBlock:
    https: |-
      server {
        listen 8080 ssl;
        #server_name ;
        # auth_basic "server auth";
        # auth_basic_user_file /etc/nginx/passwords;
        ssl_certificate /opt/app/osaaf/local/certs/cert.pem;
        ssl_certificate_key /opt/app/osaaf/local/certs/key.pem;
        location / {
          # deny node shutdown api
          if ($request_filename ~ "_shutdown") {
            return 403;
            break;
          }
      
          proxy_pass http://localhost:9200;
          proxy_http_version 1.1;
          proxy_set_header Connection "Keep-Alive";
          proxy_set_header Proxy-Connection "Keep-Alive";
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          proxy_set_header X-Forwarded-Proto $scheme;
          proxy_set_header X-Real-IP $remote_addr;
          proxy_set_header Host $http_host;
          proxy_redirect off;
        }
      
        location = / {
          proxy_pass http://localhost:9200;
          proxy_http_version 1.1;
          proxy_set_header Connection "Keep-Alive";
          proxy_set_header Proxy-Connection "Keep-Alive";
          proxy_redirect off;
          auth_basic "off";
        }
      }
    http: |-
      server {
        listen 8080 ;
        #server_name ;
        location / {
          # deny node shutdown api
          if ($request_filename ~ "_shutdown") {
            return 403;
            break;
          }
      
          proxy_pass http://localhost:9200;
          proxy_http_version 1.1;
          proxy_set_header Connection "Keep-Alive";
          proxy_set_header Proxy-Connection "Keep-Alive";
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          proxy_set_header X-Forwarded-Proto $scheme;
          proxy_set_header X-Real-IP $remote_addr;
          proxy_set_header Host $http_host;
          proxy_redirect off;
        }
      
        location = / {
          proxy_pass http://localhost:9200;
          proxy_http_version 1.1;
          proxy_set_header Connection "Keep-Alive";
          proxy_set_header Proxy-Connection "Keep-Alive";
          proxy_redirect off;
          auth_basic "off";
        }
      }
# service for nginx revers proxy
service:
  port: 8080
  type: "ClusterIP"
# application image
image:
  registry: docker.io
  repository: bitnami/elasticsearch
  tag: 6.8.6-debian-9-r23
  ## Specify a imagePullPolicy
  ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
  ## ref: http://kubernetes.io/docs/user-guide/images/#pre-pulling-images
  ##
  pullPolicy: IfNotPresent
  ## Optionally specify an array of imagePullSecrets.
  ## Secrets must be manually created in the namespace.
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
  ##
  # pullSecrets:
  #   - myRegistryKeySecretName
  ## Set to true if you would like to see extra information on logs
  ## ref:  https://github.com/bitnami/minideb-extras/#turn-on-bash-debugging
  ##
  debug: false

## String to partially override elasticsearch.fullname template (will maintain the release name)
##
# nameOverride:

## String to fully override elasticsearch.fullname template
##
# fullnameOverride:

## Bitnami Minideb image version
## ref: https://hub.docker.com/r/bitnami/minideb/tags/
##
sysctlImage:
  enabled: true
  registry: docker.io
  repository: bitnami/minideb
  tag: stretch
  ## Specify a imagePullPolicy
  ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
  ## ref: http://kubernetes.io/docs/user-guide/images/#pre-pulling-images
  ##
  pullPolicy: Always
  ## Optionally specify an array of imagePullSecrets.
  ## Secrets must be manually created in the namespace.
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
  ##
  # pullSecrets:
  #   - myRegistryKeySecretName

## Init containers parameters:
## volumePermissions: Change the owner and group of the persistent volume mountpoint to runAsUser:fsGroup values from the securityContext section.
##
volumePermissions:
  # volumePermissions.false
  enabled: true
  image:
    registry: docker.io
    repository: bitnami/minideb
    tag: stretch
    pullPolicy: Always
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ##
    # pullSecrets:
    #   - myRegistryKeySecretName
  ## Init container' resource requests and limits
  ## ref: http://kubernetes.io/docs/user-guide/compute-resources/
  ##
  resources:
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    limits: {}
    #   cpu: 100m
    #   memory: 128Mi
    requests: {}
    #   cpu: 100m
    #   memory: 128Mi

## Cluster domain
##
clusterDomain: cluster.local

## Elasticsearch cluster name
##
name: elastic

## Elasticsearch discovery node parameters
##
discovery:
  name: discovery

## Comma, semi-colon or space separated list of plugins to install at initialization
## ref: https://github.com/bitnami/bitnami-docker-elasticsearch#environment-variables
##
# plugins:

## Customize elasticsearch configuration
## ref: https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html
##
# config:

## extraVolumes and extraVolumeMounts allows you to mount other volumes
## Example Use Case: mount ssl certificates when elasticsearch has tls enabled
# extraVolumes:
#   - name: es-certs
#     secret:
#       defaultMode: 420
#       secretName: es-certs
# extraVolumeMounts:
#   - name: es-certs
#     mountPath: /certs
#     readOnly: true
service:
  name: elasticsearch
  ## coordinating-only service type
  ##
  type: ClusterIP
  ## Elasticsearch tREST API port
  ##
  port: 9200
  ## Specify the nodePort value for the LoadBalancer and NodePort service types.
  ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
  ##
  # nodePort:
  ## Provide any additional annotations which may be required. This can be used to
  ## set the LoadBalancer service type to internal only.
  ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#internal-load-balancer
  ##
  annotations: {}
  ## Set the LoadBalancer service type to internal only.
  ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#internal-load-balancer
  ##
  # loadBalancerIP:
  ## Provide functionality to use RBAC
  ##
## Elasticsearch master-eligible node parameters
##
master:
  name: master
  ## Number of master-eligible node(s) replicas to deploy
  ##
  replicas: 3
  ## master acts as master only node, choose 'no' if no further data nodes are deployed)
  ## dedicatednode: "yes"
  dedicatednode: "no"

  ## updateStrategy for ElasticSearch master statefulset
  ## ref: https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies
  ##
  updateStrategy:
    type: RollingUpdate

  heapSize: 128m
  ## Provide annotations for master-eligible pods.
  ##
  podAnnotations: {}
  ## Pod Security Context for master-eligible pods.
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  ##
  securityContext:
    enabled: true
    fsGroup: 1001
    runAsUser: 1001
  ## Affinity for pod assignment.
  ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
  ##
  affinity: {}
  ## Node labels for pod assignment. Evaluated as a template.
  ## Ref: https://kubernetes.io/docs/user-guide/node-selection/
  ##
  nodeSelector: {}
  ## Tolerations for pod assignment. Evaluated as a template.
  ## Ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []
  ## Elasticsearch master-eligible container's resource requests and limits
  ## ref: http://kubernetes.io/docs/user-guide/compute-resources/
  ##
  resources:
    ## We usually recommend not to specify default resources and to leave this as a conscious
    ## choice for the user. This also increases chances charts run on environments with little
    ## resources, such as Minikube.
    limits: {}
    #   cpu: 100m
    #   memory: 128Mi
    requests:
      cpu: 25m
      memory: 256Mi
  ## Elasticsearch master-eligible container's liveness and readiness probes
  ## ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
  ##
  livenessProbe:
    enabled: false
  #  initialDelaySeconds: 90
  #  periodSeconds: 10
  #  timeoutSeconds: 5
  #  successThreshold: 1
  #  failureThreshold: 5
  readinessProbe:
    enabled: false
  #  initialDelaySeconds: 90
  #  periodSeconds: 10
  #  timeoutSeconds: 5
  #  successThreshold: 1
  #  failureThreshold: 5

  ## Enable persistence using Persistent Volume Claims
  ## ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
  ##
  persistence:
    ## If true, use a Persistent Volume Claim, If false, use emptyDir
    ##
    enabled: true
    ## Persistent Volume Storage Class
    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is
    ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
    ##   GKE, AWS & OpenStack)
    ##
    # storageClass: "-"
    ## Persistent Volume Claim annotations
    ##
    annotations: {}
    ## Persistent Volume Access Mode
    ##
    accessModes: ReadWriteOnce
    ## Persistent Volume size
    ##
    size: 8Gi
    # existingClaim:
    volumeReclaimPolicy: Retain
    mountPath: /dockerdata-nfs
    mountSubPath: elastic
    storageType: local
    storageClass: ""
    backup:
      mountPath: /dockerdata-nfs/backup

  ## Service parameters for master-eligible node(s)
  ##
  service:
    name: elastic-master
    ## master-eligible service type
    ##
    type: ClusterIP
    ## Elasticsearch transport port
    ##
    port: 9300
    ## Specify the nodePort value for the LoadBalancer and NodePort service types.
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
    ##
    # nodePort:
    ## Provide any additional annotations which may be required. This can be used to
    ## set the LoadBalancer service type to internal only.
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#internal-load-balancer
    ##
    annotations: {}
    ## Set the LoadBalancer service type to internal only.
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#internal-load-balancer
    ##
    # loadBalancerIP:
  ## Provide functionality to use RBAC
  ##
  serviceAccount:
    ## Specifies whether a ServiceAccount should be created for the master node
    create: false
    ## The name of the ServiceAccount to use.
    ## If not set and create is true, a name is generated using the fullname template
    # name:

## Elasticsearch coordinating-only node parameters
##
coordinating:
  ## Number of coordinating-only node(s) replicas to deploy
  ##
  replicas: 2
  ## updateStrategy for ElasticSearch coordinating deployment
  ## ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy
  ##
  updateStrategy:
    type: RollingUpdate

  heapSize: 128m
  ## Provide annotations for the coordinating-only pods.
  ##
  podAnnotations: {}
  ## Pod Security Context for coordinating-only pods.
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  ##
  securityContext:
    enabled: true
    fsGroup: 1001
    runAsUser: 1001
  ## Affinity for pod assignment.
  ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
  ##
  affinity: {}
  ## Node labels for pod assignment. Evaluated as a template.
  ## Ref: https://kubernetes.io/docs/user-guide/node-selection/
  ##
  nodeSelector: {}
  ## Tolerations for pod assignment. Evaluated as a template.
  ## Ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []
  ## Elasticsearch coordinating-only container's resource requests and limits
  ## ref: http://kubernetes.io/docs/user-guide/compute-resources/
  ##
  resources:
    ## We usually recommend not to specify default resources and to leave this as a conscious
    ## choice for the user. This also increases chances charts run on environments with little
    ## resources, such as Minikube.
    limits: {}
    #   cpu: 100m
    #   memory: 128Mi
    requests:
      cpu: 25m
      memory: 256Mi
  ## Elasticsearch coordinating-only container's liveness and readiness probes
  ## ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
  ##
  livenessProbe:
    enabled: false
  #  initialDelaySeconds: 90
  #  periodSeconds: 10
  #  timeoutSeconds: 5
  #  successThreshold: 1
  #  failureThreshold: 5
  readinessProbe:
    enabled: false
  #  initialDelaySeconds: 90
  #  periodSeconds: 10
  #  timeoutSeconds: 5
  #  successThreshold: 1
  #  failureThreshold: 5
  ## Service parameters for coordinating-only node(s)
  ##

  serviceAccount:
    ## Specifies whether a ServiceAccount should be created for the coordinating node
    ##
    create: false
    ## The name of the ServiceAccount to use.
    ## If not set and create is true, a name is generated using the fullname template
    ##
    # name:

## Elasticsearch data node parameters
##
data:
  name: data
  ## Number of data node(s) replicas to deploy
  ##
  replicas: 0
  ## updateStrategy for ElasticSearch Data statefulset
  ## ref: https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies
  ##
  updateStrategy:
    type: RollingUpdate
    # rollingUpdatePartition
  heapSize: 128m
  ## Provide annotations for the data pods.
  ##
  podAnnotations: {}
  ## Pod Security Context for data pods.
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  ##
  securityContext:
    enabled: true
    fsGroup: 1001
    runAsUser: 1001
  ## Affinity for pod assignment.
  ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
  ##
  affinity: {}
  ## Node labels for pod assignment. Evaluated as a template.
  ## Ref: https://kubernetes.io/docs/user-guide/node-selection/
  ##
  nodeSelector: {}
  ## Tolerations for pod assignment. Evaluated as a template.
  ## Ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []
  ## Elasticsearch data container's resource requests and limits
  ## ref: http://kubernetes.io/docs/user-guide/compute-resources/
  ##
  resources:
    ## We usually recommend not to specify default resources and to leave this as a conscious
    ## choice for the user. This also increases chances charts run on environments with little
    ## resources, such as Minikube.
    limits: {}
    #   cpu: 100m
    #   memory: 128Mi
    requests:
      cpu: 25m
      memory: 1152Mi
  ## Elasticsearch data container's liveness and readiness probes
  ## ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
  ##
  livenessProbe:
    enabled: false
  #  initialDelaySeconds: 90
  #  periodSeconds: 10
  #  timeoutSeconds: 5
  #  successThreshold: 1
  #  failureThreshold: 5
  readinessProbe:
    enabled: false
  #  initialDelaySeconds: 90
  #  periodSeconds: 10
  #  timeoutSeconds: 5
  #  successThreshold: 1
  #  failureThreshold: 5
  ## Enable persistence using Persistent Volume Claims
  ## ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
  ##
  persistence:
    ## If true, use a Persistent Volume Claim, If false, use emptyDir
    ##
    enabled: true
    ## Persistent Volume Storage Class
    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is
    ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
    ##   GKE, AWS & OpenStack)
    ##
    # storageClass: "-"
    ## Persistent Volume Claim annotations
    ##
    annotations: {}
    ## Persistent Volume Access Mode
    ##
    accessModes:
      - ReadWriteOnce
    ## Persistent Volume size
    ##
    size: 8Gi
  ## Provide functionality to use RBAC
  ##
  serviceAccount:
    ## Specifies whether a ServiceAccount should be created for the data node
    ##
    create: false
    ## The name of the ServiceAccount to use.
    ## If not set and create is true, a name is generated using the fullname template
    ##
    # name:

## Elasticsearch ingest node parameters
##
ingest:
  enabled: false
  name: ingest
  ## Number of ingest node(s) replicas to deploy
  ##
  replicas: 0
  heapSize: 128m
  ## Provide annotations for the ingest pods.
  ##
  podAnnotations: {}
  ## Pod Security Context for ingest pods.
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  ##
  securityContext:
    enabled: true
    fsGroup: 1001
    runAsUser: 1001
  ## Affinity for pod assignment.
  ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
  ##
  affinity: {}
  ## Node labels for pod assignment. Evaluated as a template.
  ## Ref: https://kubernetes.io/docs/user-guide/node-selection/
  ##
  nodeSelector: {}
  ## Tolerations for pod assignment. Evaluated as a template.
  ## Ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []
  ## Elasticsearch ingest container's resource requests and limits
  ## ref: http://kubernetes.io/docs/user-guide/compute-resources/
  ##
  resources:
    ## We usually recommend not to specify default resources and to leave this as a conscious
    ## choice for the user. This also increases chances charts run on environments with little
    ## resources, such as Minikube.
    limits: {}
    #   cpu: 100m
    #   memory: 128Mi
    requests:
      cpu: 25m
      memory: 256Mi
  ## Elasticsearch ingest container's liveness and readiness probes
  ## ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
  ##
  livenessProbe:
    enabled: false
  #  initialDelaySeconds: 90
  #  periodSeconds: 10
  #  timeoutSeconds: 5
  #  successThreshold: 1
  #  failureThreshold: 5
  readinessProbe:
    enabled: false
  #  initialDelaySeconds: 90
  #  periodSeconds: 10
  #  timeoutSeconds: 5
  #  successThreshold: 1
  #  failureThreshold: 5
  ## Service parameters for ingest node(s)
  ##
  service:
    ## ingest service type
    ##
    type: ClusterIP
    ## Elasticsearch transport port
    ##
    port: 9300
    ## Specify the nodePort value for the LoadBalancer and NodePort service types.
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
    ##
    # nodePort:
    ## Provide any additional annotations which may be required. This can be used to
    ## set the LoadBalancer service type to internal only.
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#internal-load-balancer
    ##
    annotations: {}
    ## Set the LoadBalancer service type to internal only.
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#internal-load-balancer
    ##
    # loadBalancerIP:

## Elasticsearch curator parameters
##
curator:
  enabled: false
  name: curator
  image:
    registry: docker.io
    repository: bitnami/elasticsearch-curator
    tag: 5.8.1-debian-9-r74
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ##
    # pullSecrets:
    #   - myRegistryKeySecretName

  cronjob:
    # At 01:00 every day
    schedule: "0 1 * * *"
    annotations: {}
    concurrencyPolicy: ""
    failedJobsHistoryLimit: ""
    successfulJobsHistoryLimit: ""
    jobRestartPolicy: Never

  podAnnotations: {}

  rbac:
    # Specifies whether RBAC should be enabled
    enabled: false

  serviceAccount:
    # Specifies whether a ServiceAccount should be created
    create: true
    # The name of the ServiceAccount to use.
    # If not set and create is true, a name is generated using the fullname template
    name:

  psp:
    # Specifies whether a podsecuritypolicy should be created
    create: false

  hooks:
    install: false
    upgrade: false

  # run curator in dry-run mode
  dryrun: false

  command: ["curator"]
  env: {}

  configMaps:
    # Delete indices older than 90 days
    action_file_yml: |-
      ---
      actions:
        1:
          action: delete_indices
          description: "Clean up ES by deleting old indices"
          options:
            timeout_override:
            continue_if_exception: False
            disable_action: False
            ignore_empty_list: True
          filters:
          - filtertype: age
            source: name
            direction: older
            timestring: '%Y.%m.%d'
            unit: days
            unit_count: 90
            field:
            stats_result:
            epoch:
            exclude: False
    # Default config (this value is evaluated as a template)
    config_yml: |-
      ---
      client:
        hosts:
          - {{ template "elasticsearch.coordinating.fullname" . }}.{{ .Release.Namespace }}.svc.{{ .Values.clusterDomain }}
        port: {{ .Values.coordinating.service.port }}
        # url_prefix:
        # use_ssl: True
        # certificate:
        # client_cert:
        # client_key:
        # ssl_no_validate: True
        # http_auth:
        # timeout: 30
        # master_only: False
      # logging:
      #   loglevel: INFO
      #   logfile:
      #   logformat: default
      #   blacklist: ['elasticsearch', 'urllib3']

  ## Curator resources requests and limits
  ## ref: http://kubernetes.io/docs/user-guide/compute-resources/
  ##
  resources:
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    limits: {}
    #  cpu: 100m
    #  memory: 128Mi
    requests: {}
    #  cpu: 100m
    #  memory: 128Mi

  priorityClassName: ""

  # extraVolumes and extraVolumeMounts allows you to mount other volumes
  # Example Use Case: mount ssl certificates when elasticsearch has tls enabled
  # extraVolumes:
  #   - name: es-certs
  #     secret:
  #       defaultMode: 420
  #       secretName: es-certs
  # extraVolumeMounts:
  #   - name: es-certs
  #     mountPath: /certs
  #     readOnly: true

  ## Add your own init container or uncomment and modify the given example.
  ##
  extraInitContainers: {}
  ## Don't configure S3 repository till Elasticsearch is reachable.
  ## Ensure that it is available at http://elasticsearch:9200
  ##
  # elasticsearch-s3-repository:
  #   image: bitnami/minideb:latest
  #   imagePullPolicy: "IfNotPresent"
  #   command:
  #   - "/bin/bash"
  #   - "-c"
  #   args:
  #   - |
  #     ES_HOST=elasticsearch
  #     ES_PORT=9200
  #     ES_REPOSITORY=backup
  #     S3_REGION=us-east-1
  #     S3_BUCKET=bucket
  #     S3_BASE_PATH=backup
  #     S3_COMPRESS=true
  #     S3_STORAGE_CLASS=standard
  #     install_packages curl && \
  #     ( counter=0; while (( counter++ < 120 )); do curl -s http://${ES_HOST}:${ES_PORT} >/dev/null 2>&1 && break; echo "Waiting for elasticsearch $counter/120"; sleep 1; done ) && \
  #     cat <<EOF | curl -sS -XPUT -H "Content-Type: application/json" -d @- http://${ES_HOST}:${ES_PORT}/_snapshot/${ES_REPOSITORY} \
  #     {
  #       "type": "s3",
  #       "settings": {
  #         "bucket": "${S3_BUCKET}",
  #         "base_path": "${S3_BASE_PATH}",
  #         "region": "${S3_REGION}",
  #         "compress": "${S3_COMPRESS}",
  #         "storage_class": "${S3_STORAGE_CLASS}"
  #       }
  #     }

## Elasticsearch Prometheus exporter configuration
## ref: https://hub.docker.com/r/bitnami/elasticsearch-exporter/tags/
##
metrics:
  enabled: false
  name: metrics
  image:
    registry: docker.io
    repository: bitnami/elasticsearch-exporter
    tag: 1.1.0-debian-9-r134
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ##
    # pullSecrets:
    #   - myRegistryKeySecretName
  ## Elasticsearch Prometheus exporter service type
  ##
  service:
    type: ClusterIP
    ## Provide any additional annotations which may be required. This can be used to
    ## set the LoadBalancer service type to internal only.
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#internal-load-balancer
    ##
    annotations:
      prometheus.io/scrape: "true"
      prometheus.io/port: "9114"
  ## Elasticsearch Prometheus exporter resource requests and limits
  ## ref: http://kubernetes.io/docs/user-guide/compute-resources/
  ##
  resources:
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    limits: {}
    #   cpu: 100m
    #   memory: 128Mi
    requests: {}
    #   cpu: 100m
    #   memory: 128Mi
  ## Metrics exporter pod Annotation and Labels
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  ##
  podAnnotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "8080"

  ## Prometheus Operator ServiceMonitor configuration
  ##
  serviceMonitor:
    enabled: false
    ## Namespace in which Prometheus is running
    ##
    # namespace: monitoring

    ## Interval at which metrics should be scraped.
    ## ref: https://github.com/coreos/prometheus-operator/blob/master/Documentation/api.md#endpoint
    ##
    # interval: 10s

    ## Timeout after which the scrape is ended
    ## ref: https://github.com/coreos/prometheus-operator/blob/master/Documentation/api.md#endpoint
    ##
    # scrapeTimeout: 10s

    ## ServiceMonitor selector labels
    ## ref: https://github.com/bitnami/charts/tree/master/bitnami/prometheus-operator#prometheus-configuration
    ##
    # selector:
    #   prometheus: my-prometheus

## Bundled Kibana parameters
##
kibana:
  elasticsearch:
    hosts:
      - '{{ include "elasticsearch.coordinating.fullname" . }}'
    port: 9200
